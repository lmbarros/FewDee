/**
 * Abstracted input translates low-level input events like "pressed space" and
 * "moved joystick a bit to the right" to high-level commands like "jump" and
 * "walk right".
 *
 * Authors: Leandro Motta Barros
 */

module fewdee.abstracted_input;

import allegro5.allegro;
import fewdee.low_level_event_handler;


/**
 * A structure passed as parameter to handlers of high-level commands. Its
 * fields are just generic data fields, and shouldn't be used directly. Instead,
 * FewDee provides some magic that allows to read from and write to these fields
 * using more meaningful names, like $(D sourceIsMouse) or $(D
 * sourceIsKeyboard).
 */
public struct HighLevelCommandHandlerParam
{
   /**
    * This is the source of the command. For mouse events, this will be $(D
    * al_get_mouse_event_source()). For keyboard events, it will be $(D
    * al_get_keyboard_event_source()). For joystick events, it will be the $(D
    * ALLEGRO_JOYSTICK*) returned by $(D al_get_joystick()).
    */
   private void* source;
}


/// Was the command generated by the mouse?
public @property bool sourceIsMouse(
   const ref HighLevelCommandHandlerParam param)
{
   return param.source == al_get_mouse_event_source();
}


/// Was the command generated by the keyboard?
public @property bool sourceIsKeyboard(
   const ref HighLevelCommandHandlerParam param)
{
   return param.source == al_get_keyboard_event_source();
}


/// Was the command generated by a given joystick?
public bool sourceIsJoystick(const ref HighLevelCommandHandlerParam param,
                             ALLEGRO_JOYSTICK* joystick)
{
   return param.source == joystick;
}


/// A delegate used to handle high-level commands.
public alias void delegate(in ref HighLevelCommandHandlerParam param)
   HighLevelCommandHandler;


/**
 * A $(D CommandTrigger_t) is a delegate that verifies if a given low-level
 * Allegro event has triggered a specific high-level command.
 *
 * The $(D event) parameter is the low-level Allegro event. In the $(D param)
 * parameter, the delegate passes whatever it wants to be passed to whoever will
 * handle the high-level command. A $(D CommandTrigger_t) shall return $(D true)
 * if the low-level has triggered the high-level command it is trying to
 * recognize, or $(D false) otherwise.
 */
public alias bool delegate(in ref ALLEGRO_EVENT event,
                           out HighLevelCommandHandlerParam param)
   CommandTrigger_t;


/**
 * Creates a command trigger that triggers a high-level command in response to
 * key presses.
 */
public CommandTrigger_t keyPress(int keyCode)
{
   return delegate(in ref ALLEGRO_EVENT event,
                   out HighLevelCommandHandlerParam param)
   {
      if (event.type == ALLEGRO_EVENT_KEY_DOWN
          && event.keyboard.keycode == keyCode)
      {
         param.source = al_get_keyboard_event_source();
         return true;
      }

      return false;
   };
}


/**
 * Creates a command trigger that triggers a high-level command in response to a
 * joystick button press.
 */
public CommandTrigger_t joyButtonPress(int button)
{
   return delegate(in ref ALLEGRO_EVENT event,
                   out HighLevelCommandHandlerParam param)
   {
      if (event.type == ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN
          && event.joystick.button == button)
      {
         param.source = cast(void*)(event.joystick.id);
         return true;
      }

      return false;
   };
}


/**
 * A $(D LowLevelEventHandler) that listens to low-level events, checks if they
 * trigger high-level commands and, if they do, call the handlers of these
 * high-level commands.
 *
 * The template parameter $(D HighLevelCommandsEnum) must be an $(D enum)
 * containing the high-level commands this $(D AbstractedInput) will be able to
 * handle.
 */
class AbstractedInput(HighLevelCommandsEnum): LowLevelEventHandler
   if (is(HighLevelCommandsEnum == enum))
{
   /**
    * Handles the low-level events. Calls the high-level handlers, if
    * appropriate.
    */
   public override void handleEvent(in ref ALLEGRO_EVENT event)
   {
      foreach (mapping; _mappings)
      {
         HighLevelCommandHandlerParam param;
         if (mapping.lowLevelCommand(event, param))
         {
            if (mapping.highLevelCommand in _handlers)
            {
               // call handler
               foreach(handler; _handlers[mapping.highLevelCommand])
                  handler(param);
            }

            // Give a chance to more high-level commands to be executed. Perhaps
            // this should be replaceable with a 'break' by passing a certain
            // template parameter (in order to implement a policy of a low-level
            // event can trigger only one high-level command).
            continue;
         }
      }
   }


   /// Removes all the mappings from low-level events to high-level commands.
   public final void clearMappings()
   {
      _mappings = [ ];
   }


   /**
    * Adds a new mapping from a low-level event to a high-level command.
    *
    * Parameters:
    *    lowLevelCommand = A delegate that checks if the desired low-level
    *       command was issued.
    *    highLevelCommand = The high-level command to trigger when the
    *       lowLevelCommand is issued.
    */
   public final void addMapping(CommandTrigger_t lowLevelCommand,
                                HighLevelCommandsEnum highLevelCommand)
   {
      _mappings ~= mapping_t(lowLevelCommand, highLevelCommand);
   }

   /**
    * Adds a new handler that will be called whenever a given high-level command
    * is triggered.
    *
    * Parameters:
    *    highLevelCommand = The desired high-level command.
    *    handler = The function (er, delegate) to call when $(D
    *       highLevelCommand) is triggered.
    */
   public final void addHandler(HighLevelCommandsEnum highLevelCommand,
                                HighLevelCommandHandler handler)
   {
      _handlers[highLevelCommand] ~= handler;
   }

   /// A structure storing one mapping from a low-level to a high-level command.
   private struct mapping_t
   {
      public CommandTrigger_t lowLevelCommand;
      public HighLevelCommandsEnum highLevelCommand;
   }

   /// All the mappings from low-level to a high-level commands.
   private mapping_t[] _mappings;

   /**
    * The callbacks to be called in response to high-level commands. This is a
    * map, indexed by the high-level command. It value is an array containing
    * all the callbacks to be called when that high-level command is triggered.
    */
   private HighLevelCommandHandler[][HighLevelCommandsEnum] _handlers;
}
