Architecture
--------------

Notes about the redesign (or, in fact, the first real design) of the
architecture.

Engine (core)
   - knows who is inited...
   - ...so that it can stop them afterward
   - initializes the Allegro core and perhaps some other module
     (native dialogs?)

EventManager
   - loads addons: mouse, keyboard, joystick.
   - allows to register and de-register event listeners
   - translates Allegro events to FewDee events (performance?! use tricks like
     free lists?)
   - TODO: needs to be called by the main loop, so that it can call
     al_get_next_event() andthe like.
        - TODO: Perhaps it should somehow provide run()
   - TODO: how to identify events? OK, subsystem/event pair, but what are
     "subsystem" and "event"? Must be easily extensible and not too
     slow. Benchmark uints versus strings.
   - In addition to "please call this callback when this specific
     event happens", we need a low-level event handler, to implement
     things like AbstractedInput. This should probably be usable by
     end users... they should be able to provide their own
     abstracted input mechanisms, if desired.

DisplayManager
   - loads lots of addons: image, font, ttf. Perhaps primitives.
   - provide information about available monitors and their capabilities
   - create, destroy, manage displays.
   - get the default display.
   - display identified by string IDs.
   - TODO: what is the default display? One named "default"? The first created?
     One explicitly flagged as such?

AudioManager
   - loads addons: audio, audio codecs.
   - play samples and streams (play, pause, loop, volume, etc)
   - stops everything upon destruction
   - TODO: how to chose the parameter to al_reserve_samples()?

ResourceManager
   - seems that must be destroyed after all other managers (just the core is
     destroyed afterward), because they may still reference stuff from here
     (like, streams playing -- if this is destroyed before AudioManager,
     AudioManager may try to read from a deleted audio stream).
   - Resources are identified by strings.
   - Clean resources by regexp: "please, clean resources named "level_01-*".
   - TODO: how to specify which resources are loaded from which files? May want
     to read from a hardcoded string or from a file.
   - TODO: and what about resource archives? Not an issue for now, but... maybe
     a resource manager can use some kind of helper class to actually read data
     from disk... by default, uses a FileSystemReader, but could be replaced by
     an ArchiveReader or whatever.
        - How Allegro deals with this: there a struct,
          ALLEGRO_FILE_INTERFACE, with pointers to all file
          system-related functions (open, close, read, write, flush,
          tell, seek, etc). Then, there are functions like
          al_set_new_file_interface() and
          al_set_standard_file_interface() that allow to change the
          current set of funcions used for all I/O operations in the
          current thread.
        - So, a Reader would have to somehow provide pointers to these
          functions.
        - And how to set the current Reader? An IOManager? Or add this
          to the core engine? In any case, reading from the file
          system will be the default, so I don't have to worry about
          this now. Er, I may want to add a mean to set the data root
          directory (CWD by default)... but then, I would have to
          provide the interfaces, and a FileSystemReader with a
          setRoot() method.
        - Also note that there are funcions like al_load_bitmap_f()
          that take a pointer to an ALLEGRO_FILE -- these functions
          are probably a better alternative to use (if possible),
          since they don't rely on a global state set by
          al_set_standard_file_interface() and friends.
   - TODO: one resource manager to rule them all or one resource manager per
     type of resource? Do I want to allow "user-defined" resources (like, say,
     "scripts")?
        - Best idea so far: add a pool of "generic resources"
          (LowLevelResources). The user can put whatever he wants
          there. Not elegant, but let's KISS.
   - TODO: how to deal with the "one image file contains many 'logical
     bitmaps', which may be combined in various ways in a single sprite?"

 Post-Architecture Organization
--------------------------------

 - If we use the destructor to free low-level resources, then we can
   just create 'scope' resources when needed (specially in examples,
   where there is always that "eill need to free resources"
   disclaimer). Must consider this change after the main "conversion"
   is complete!

 - Scan the untouched modules for things like
   - Adding 'final' or making methods free functions called with UFCS.
   - Adding $(D ...) macros
   - Improving and updating docs
   - Replace foo_ with _foo.

 - Consider modifying the canned updaters to templates. The current
   design, based in interfaces, will not work with
   AudioSampleInstance, which is a struct (and I'd like to have canned
   updaters for fade in and fade out, at least).

 Assorted TODOs
----------------

Check how exactly font sizes are specified in Allegro. Ensure that
AllegroFont works as documented.

Think about a sane way to do manage Allegro resources. Some ideas and
thoughts:
   - Not all resources have a 1:1 mapping between files and the
     resources themselves. Case in point: one bitmap may contain
     several images which are intented to be used separately (a sprite
     sheet); furthermore, a single "sprite template" could reference
     many of these "sub bitmaps".
   - A resource manager is a global thing, since resources may be
     shared between different game states (and someone could use a
     resource manager without using game states).
   - It might not be a bad idea to have resources manually freed. They
     are usually allocated and de-allocated at very specific moments
     (loading a new level, for example); it's not like, say, memory,
     which is allocated and free everywhere. The idea is: "resource
     manager, please load MyFont.ttf, size 22 and associate with the
     strinf 'NiceFont'." When no longer needed, we can say "resource
     manager, free 'NiceFont' please." If anyone is still referencing
     that font, that's their problem, the program will explode.
   - To ease a manual freeing mechanism, we can have a regexp-based
     freeing scheme. Like "free all resources matching '*-level_1-*',
     please".
   - It would be possible to create some kind of "RAII proxy" to a
     resource manager. Adding resources to this "proxy" would add the
     resource to the resource manager. But the proxy remembers which
     resources it has added, so it cann free them when
     destroyed. (Would need to be 'scope'.)
   - A resource manager will free (say, call the free() method) of all
     its resources when it gets destroyed. Perhaps it should be
     'scope'.
   - So, resources don't have to reference counted. Bye bye those
     ref-counted Allegro wrappers.
   - Question: one big resource manager for all resource types or one
     resource manager per resource type (perhaps even user-defined
     resources)? In the latter case, maybe a template or a mixin could
     provide most of the implementation.
   - The resource manager would be, perhaps, the point where we chose
     between a real file system or an archive file
     system. Perhaps. Must think about this.

Go back to premultiplied alpha. Now that I understand it, it makes
much more sense. Maybe (this is longer term) I should have some way to
specify if the bitmap being loaded does already have the colors with
premultiplied alpha or not. Not doing the premultiplication uppon
loading (and having and editor that allows to edit the alpha channel
independently) would enable those neat effects like glowing neon signs
with a single image.

GUIsh what about z-order? Drawables have a "z" property; I can
implement a picking visitor that takes it into account. Then, GUIsh
should use this. Picking will pick Drawables only (and return a node
path!).

OSGUIsh can work with any node; GUIsh should allow that, too: any node
should be registerable; will need to walk up the picked node path
until finding a registered node (or not).

GUIsh: allow hierarchy of objects. (Will need to make AABBs much
better on the way.)

Sprite constructor taking arbitrary number of file names.

Sprite.contains() -> by transparency? Multiple containment policies?

Add means to remove objects/handlers from GUIsh.

Add means to remove objects/handlers from Updater. If necessary, make
the canned updaters compatible with this.

Add means to remove objects/handlers from AbstractedInput.

Think about ways to make AbstractedInput more usable. Think about
moving a character around. There is a set of low-level events (left
key up, right_key_down...) that work together to generate the
high-level commands (Think about diagonals; specially in a discrete
grid; if "up" and "left" are pressed within a very short period, we
want diagonal walking events. This is no one-to-one, as the current
design assumes). And even then, the high-level commands could be
implemented in different ways; do we have a "start walking right"
command? Or we want to manage a "currently walking right" state? Or
perhaps generate a sequence of "walked one step to the right" events?
   - Here's the result of some recent thinking about it: The problem
     is that the current design always maps events to commands, while
     sometimes we simply want to update some state that can be queried
     by the game at some specific moment. So, in addition to executing
     callbacks, AbstractedInput should be able to maintain some state
     updated as the user generates low-level events.
   - What kind of state? Boolean, integer, floating point, perhaps
     even "enum". A "direction" state, for 4- or 8-directions would be
     very useful, too.
   - We could call state changed callbacks (but I don't know if this
     would be useful).
   - Different strategies for state updates should be usable. For
     example, a float state could gradually go back to zero in the
     absence of an input signal, or keep the value "forever".

Create a "virtual screen" with a given "virtual size". Draw everything
relative to this virtual screen. Scale when drawing. But allow to use
"real pixels", too. (This would be an option when creating (or
re-creating, if possible) the display).

Add Text vertical alignment.

What if a state gets two events in the same "turn" and calls
pushState() in both of them? (Practical example: the player presses
"ESC" to get to the "in-game menu" state , and in the same "turn" he
is killed by a bullet, which triggers a transition to the "game over"
state.) Using Allegro events to manage the stack of states could be of
any help?

For Sprite: there is a handy al_get_parent_bitmap() function; this
would allow us to keep subbitmaps internally and return the "real"
bitmap for sorting purposes. Anyway, must implement a benchmark to
test how slower it is to render from different bitmaps versus from a
single one versus sub-bitmaps.

Group.addChild(): accept multiple children at a time? Technically,
would have to be renamed addChildren()... don't know if is necessary
in practice... must think about it.

Latest version of DAllegro includes a al_run_allegro() function that
should be used instead of simply putting all the code directly on
main() (for portability reasons). Check this out.

Make Sprites' AABB work for rotated sprite. Same for SRT.

Consider making Sprite and Text "base classes" (they would become more
like wrappers around Allegro objects), and create SpriteNode and
TextNode classes for the scene graph.

Consider using premultiplied alpha by default. Think on a nice way to
represent colors in the API.

Add more Command Triggers, including one to recognize sequences of
keys (both with time-constraints, like in fighting games, and without,
like in IDKFA).


 Optimization
--------------

Child nodes call a parents' method to tell to update their bounding
boxes because their own bounding box changed. This way, we'll always
have updated bounding boxes. [ initial implementation will always
recompute the AABB; this faster method will be implemented if deemed
necessary. ]

DrawingVisitor: Allow Drawables to share a common Transform. Then,
sort by transform to spare a couple of calls to
al_use_transform(). (Need to benchmark this; perhaps leave the sorting
policy as something user-definable)

DrawingVisitor: Add a 'bitmap' property to Drawables. Then, sort by
bitmap to avoid changing texture from draw to draw. BTW, remember to
take subbitmaps into account. (Need to benchmark this; perhaps leave
the sorting policy as something user-definable)

Consider replacing fewdee.all' with 'fewdee._'. This seems to be an
emerging standard in the D community.

 Longer term
-------------

Consider hiding Allegro completely. Or perhaps allow multiple
back-ends.

Think about a decent way to represent input devices uniquely. Also,
consider that joysticks can be plugged or unplugged at any time. This
should be supported.


 Some SDL 2 notes
------------------

If SDL 2 were complete by the time I started working on FewDee, it
would probably my choice for the "backend". As of now, I don't regret
to have chosen Allegro at all, but I know that SDL is a strong
alternative. So someday, I may chose to use SDL as the backend (or as
an alternative backend), and therefore it is interesting to see how
SDL 2 and Allegro 5 differ, and to what extent they are similar.

MULTIPLE WINDOWS: Both support multiple windows (or multiple screens,
in a multi-head setup). SDL calls each one a "screen"; Allegro,
"display".

HARDWARE AND SOFTWARE BITMAPS: Both have the concept of images stored
in either GPU (hardware) or CPU memory (software). In Allegro, there
is a single class: Bitmap; when it has a the ALLEGRO_MEMORY_BITMAP
flag enabled, it is in "CPU memory"; otherwise, it is in "GPU
memory". SDL 2 has two different classes: Surface (for "software
bitmaps") and Texture (for "hardware bitmaps").

CONVERSIONS BETWEEN HARDWARE AND SOFTWARE BITMAPS: Allegro seems to
allow the use of both bitmap types interchangeably (with different
performance levels). SDL 2 has a SDL_CreateTextureFromSurface()
function to convert from Surface to Texture; the opposite conversion
doesn't seem to exist.

BLIT: SDL_RenderCopy() blits part of a Texture to the current render
target, possibly with scaling; SDL_RenderCopyEx() additionally allows
to rotate and flip the Texture. SDL_BlitSurface() allow to blit a
Surface to another one (with scaling only). All SDL bliting respects
the current;y set blending mode, it seems. Allegro seems to allow both
types of bitmap to be written to each other freely (though there are
certainly performance trade-offs).

SUB-BITMAPS: Allegro allows to create explicit sub-bitmaps; SDL
doesn't have this concept, but all blitting functions take a "source
rectangle" parameter, that allow to draw just a part of the source
image.

COORDINATES: SDL 2 seems to use integer coordinates everywhere (via
SDL_Rect, sometimes). Allegro uses float coodinates. This is an
important difference!
