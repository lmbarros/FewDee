 Assorted TODOs
----------------

If we use the destructor to free low-level resources, then we can just
create 'scope' resources when needed (specially in examples, where
there is always that "eill need to free resources" disclaimer). Must
consider this change after the main "conversion" is complete!

Create canned updaters for audio.

Initialization: if the sound cannot be initialized, the audio examples
crash. There must be an easy and clean way for checking if the sound
was not properly initialized (so that programs usinf FewDee could say
"sorry, no sound, do you want to proceed anyway?"  (Looks like we are
just throwing an exception now, so this part is easy). But then, if
proceeding without sound support, no audio-related call should throw
anything. All calls should simply be no-ops. This would be great,
since the FewDee user wouldn't need to code worrying if audio is
available or not. Graceful degration.

Check how exactly font sizes are specified in Allegro. Ensure that
AllegroFont works as documented.

Concerning resources:
   - Not all resources have a 1:1 mapping between files and the
     resources themselves. Case in point: one bitmap may contain
     several images which are intented to be used separately (a sprite
     sheet); furthermore, a single "sprite template" could reference
     many of these "sub bitmaps".
   - It would be possible to create some kind of "RAII proxy" to a
     resource manager. Adding resources to this "proxy" would add the
     resource to the resource manager. But the proxy remembers which
     resources it has added, so it cann free them when
     destroyed. (Would need to be 'scope'.) I don't know if this
     really necessary. Better wait until there is some real code using
     FewDee.
   - The resource manager would be, perhaps, the point where we chose
     between a real file system or an archive file
     system. Perhaps. Must think about this.

GUIsh what about z-order? Drawables have a "z" property; I can
implement a picking visitor that takes it into account. Then, GUIsh
should use this. Picking will pick Drawables only (and return a node
path!).

OSGUIsh can work with any node; GUIsh should allow that, too: any node
should be registerable; will need to walk up the picked node path
until finding a registered node (or not).

GUIsh: allow hierarchy of objects. (Will need to make AABBs much
better on the way.)

Sprite constructor taking arbitrary number of file names.

Sprite.contains() -> by transparency? Multiple containment policies?

Add means to remove objects/handlers from GUIsh.

Add means to remove objects/handlers from AbstractedInput.

Think about ways to make AbstractedInput more usable. Think about
moving a character around. There is a set of low-level events (left
key up, right_key_down...) that work together to generate the
high-level commands (Think about diagonals; specially in a discrete
grid; if "up" and "left" are pressed within a very short period, we
want diagonal walking events. This is no one-to-one, as the current
design assumes). And even then, the high-level commands could be
implemented in different ways; do we have a "start walking right"
command? Or we want to manage a "currently walking right" state? Or
perhaps generate a sequence of "walked one step to the right" events?
   - Here's the result of some recent thinking about it: The problem
     is that the current design always maps events to commands, while
     sometimes we simply want to update some state that can be queried
     by the game at some specific moment. So, in addition to executing
     callbacks, AbstractedInput should be able to maintain some state
     updated as the user generates low-level events.
   - What kind of state? Boolean, integer, floating point, perhaps
     even "enum". A "direction" state, for 4- or 8-directions would be
     very useful, too.
   - We could call state changed callbacks (but I don't know if this
     would be useful).
   - Different strategies for state updates should be usable. For
     example, a float state could gradually go back to zero in the
     absence of an input signal, or keep the value "forever".

Create a "virtual screen" with a given "virtual size". Draw everything
relative to this virtual screen. Scale when drawing. But allow to use
"real pixels", too. (This would be an option when creating (or
re-creating, if possible) the display).

Add Text vertical alignment.

For Sprite: there is a handy al_get_parent_bitmap() function; this
would allow us to keep subbitmaps internally and return the "real"
bitmap for sorting purposes. Anyway, must implement a benchmark to
test how slower it is to render from different bitmaps versus from a
single one versus sub-bitmaps.

Group.addChild(): accept multiple children at a time? Technically,
would have to be renamed addChildren()... don't know if is necessary
in practice... must think about it.

Latest version of DAllegro includes a al_run_allegro() function that
should be used instead of simply putting all the code directly on
main() (for portability reasons). Check this out.

Make Sprites' AABB work for rotated sprite. Same for SRT.

Consider making Sprite and Text "base classes" (they would become more
like wrappers around Allegro objects), and create SpriteNode and
TextNode classes for the scene graph.

Add more Command Triggers, including one to recognize sequences of
keys (both with time-constraints, like in fighting games, and without,
like in IDKFA).


 Optimization
--------------

Child nodes call a parents' method to tell to update their bounding
boxes because their own bounding box changed. This way, we'll always
have updated bounding boxes. [ initial implementation will always
recompute the AABB; this faster method will be implemented if deemed
necessary. ]

DrawingVisitor: Allow Drawables to share a common Transform. Then,
sort by transform to spare a couple of calls to
al_use_transform(). (Need to benchmark this; perhaps leave the sorting
policy as something user-definable)

DrawingVisitor: Add a 'bitmap' property to Drawables. Then, sort by
bitmap to avoid changing texture from draw to draw. BTW, remember to
take subbitmaps into account. (Need to benchmark this; perhaps leave
the sorting policy as something user-definable)

Consider replacing fewdee.all' with 'fewdee._'. This seems to be an
emerging standard in the D community.

 Longer term
-------------

Consider hiding Allegro completely. Or perhaps allow multiple
back-ends.

Think about a decent way to represent input devices uniquely. Also,
consider that joysticks can be plugged or unplugged at any time. This
should be supported.


 Some SDL 2 notes
------------------

If SDL 2 were complete by the time I started working on FewDee, it
would probably my choice for the "backend". As of now, I don't regret
to have chosen Allegro at all, but I know that SDL is a strong
alternative. So someday, I may chose to use SDL as the backend (or as
an alternative backend), and therefore it is interesting to see how
SDL 2 and Allegro 5 differ, and to what extent they are similar.

MULTIPLE WINDOWS: Both support multiple windows (or multiple screens,
in a multi-head setup). SDL calls each one a "screen"; Allegro,
"display".

HARDWARE AND SOFTWARE BITMAPS: Both have the concept of images stored
in either GPU (hardware) or CPU memory (software). In Allegro, there
is a single class: Bitmap; when it has a the ALLEGRO_MEMORY_BITMAP
flag enabled, it is in "CPU memory"; otherwise, it is in "GPU
memory". SDL 2 has two different classes: Surface (for "software
bitmaps") and Texture (for "hardware bitmaps").

CONVERSIONS BETWEEN HARDWARE AND SOFTWARE BITMAPS: Allegro seems to
allow the use of both bitmap types interchangeably (with different
performance levels). SDL 2 has a SDL_CreateTextureFromSurface()
function to convert from Surface to Texture; the opposite conversion
doesn't seem to exist.

BLIT: SDL_RenderCopy() blits part of a Texture to the current render
target, possibly with scaling; SDL_RenderCopyEx() additionally allows
to rotate and flip the Texture. SDL_BlitSurface() allow to blit a
Surface to another one (with scaling only). All SDL bliting respects
the current;y set blending mode, it seems. Allegro seems to allow both
types of bitmap to be written to each other freely (though there are
certainly performance trade-offs).

SUB-BITMAPS: Allegro allows to create explicit sub-bitmaps; SDL
doesn't have this concept, but all blitting functions take a "source
rectangle" parameter, that allow to draw just a part of the source
image.

COORDINATES: SDL 2 seems to use integer coordinates everywhere (via
SDL_Rect, sometimes). Allegro uses float coodinates. This is an
important difference!
