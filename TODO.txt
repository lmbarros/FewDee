Check how exactly font sizes are specified in Allegro. Ensure that
AllegroFont works as documented.

Think about a sane way to do manage Allegro resources. Some ideas and
thoughts:
   - Not all resources have a 1:1 mapping between files and the
     resources themselves. Case in point: one bitmap may contain
     several images which are intented to be used separately (a sprite
     sheet); furthermore, a single "sprite template" could reference
     many of these "sub bitmaps".
   - A resource manager is a global thing, since resources may be
     shared between different game states (and someone could use a
     resource manager without using game states).
   - It might not be a bad idea to have resources manually freed. They
     are usually allocated and de-allocated at very specific moments
     (loading a new level, for example); it's not like, say, memory,
     which is allocated and free everywhere. The idea is: "resource
     manager, please load MyFont.ttf, size 22 and associate with the
     strinf 'NiceFont'." When no longer needed, we can say "resource
     manager, free 'NiceFont' please." If anyone is still referencing
     that font, that's their problem, the program will explode.
   - To ease a manual freeing mechanism, we can have a regexp-based
     freeing scheme. Like "free all resources matching '*-level_1-*',
     please".
   - It would be possible to create some kind of "RAII proxy" to a
     resource manager. Adding resources to this "proxy" would add the
     resource to the resource manager. But the proxy remembers which
     resources it has added, so it cann free them when
     destroyed. (Would need to be 'scope'.)
   - A resource manager will free (say, call the free() method) of all
     its resources when it gets destroyed. Perhaps it should be
     'scope'.
   - So, resources don't have to reference counted. Bye bye those
     ref-counted Allegro wrappers.
   - Question: one big resource manager for all resource types or one
     resource manager per resource type (perhaps even user-defined
     resources)? In the latter case, maybe a template or a mixin could
     provide most of the implementation.
   - The resource manager would be, perhaps, the point where we chose
     between a real file system or an archive file
     system. Perhaps. Must think about this.

Go back to premultiplied alpha. Now that I understand it, it makes
much more sense. Maybe (this is longer term) I should have some way to
specify if the bitmap being loaded does already have the colors with
premultiplied alpha or not. Not doing the premultiplication uppon
loading (and having and editor that allows to edit the alpha channel
independently) would enable those neat effects like glowing neon signs
with a single image.

GUIsh what about z-order? Drawables have a "z" property; I can
implement a picking visitor that takes it into account. Then, GUIsh
should use this. Picking will pick Drawables only (and return a node
path!).

OSGUIsh can work with any node; GUIsh should allow that, too: any node
should be registerable; will need to walk up the picked node path
until finding a registered node (or not).

GUIsh: allow hierarchy of objects. (Will need to make AABBs much
better on the way.)

Sprite constructor taking arbitrary number of file names.

Sprite.contains() -> by transparency? Multiple containment policies?

Add means to remove objects/handlers from GUIsh.

Add means to remove objects/handlers from Updater. If necessary, make
the canned updaters compatible with this.

Add means to remove objects/handlers from AbstractedInput.

Think about ways to make AbstractedInput more usable. Think about
moving a character around. There is a set of low-level events (left
key up, right_key_down...) that work together to generate the
high-level commands (Think about diagonals; specially in a discrete
grid; if "up" and "left" are pressed within a very short period, we
want diagonal walking events. This is no one-to-one, as the current
design assumes). And even then, the high-level commands could be
implemented in different ways; do we have a "start walking right"
command? Or we want to manage a "currently walking right" state? Or
perhaps generate a sequence of "walked one step to the right" events?

Create a "virtual screen" with a given "virtual size". Draw everything
relative to this virtual screen. Scale when drawing. But allow to use
"real pixels", too. (This would be an option when creating (or
re-creating, if possible) the display).

Add Text vertical alignment.

What if a state gets two events in the same "turn" and calls
pushState() in both of them? (Practical example: the player presses
"ESC" to get to the "in-game menu" state , and in the same "turn" he
is killed by a bullet, which triggers a transition to the "game over"
state.) Using Allegro events to manage the stack of states could be of
any help?

For Sprite: there is a handy al_get_parent_bitmap() function; this
would allow us to keep subbitmaps internally and return the "real"
bitmap for sorting purposes. Anyway, must implement a benchmark to
test how slower it is to render from different bitmaps versus from a
single one versus sub-bitmaps.

Group.addChild(): accept multiple children at a time? Technically,
would have to be renamed addChildren()... don't know if is necessary
in practice... must think about it.

Latest version of DAllegro includes a al_run_allegro() function that
should be used instead of simply putting all the code directly on
main() (for portability reasons). Check this out.

Make Sprites' AABB work for rotated sprite. Same for SRT.

Consider making Sprite and Text "base classes" (they would become more
like wrappers around Allegro objects), and create SpriteNode and
TextNode classes for the scene graph.

Consider using premultiplied alpha by default. Think on a nice way to
represent colors in the API.

Add more Command Triggers, including one to recognize sequences of
keys (both with time-constraints, like in fighting games, and without,
like in IDKFA).


 Optimization
--------------

Child nodes call a parents' method to tell to update their bounding
boxes because their own bounding box changed. This way, we'll always
have updated bounding boxes. [ initial implementation will always
recompute the AABB; this faster method will be implemented if deemed
necessary. ]

DrawingVisitor: Allow Drawables to share a common Transform. Then,
sort by transform to spare a couple of calls to
al_use_transform(). (Need to benchmark this; perhaps leave the sorting
policy as something user-definable)

DrawingVisitor: Add a 'bitmap' property to Drawables. Then, sort by
bitmap to avoid changing texture from draw to draw. BTW, remember to
take subbitmaps into account. (Need to benchmark this; perhaps leave
the sorting policy as something user-definable)

Consider replacing fewdee.all' with 'fewdee._'. This seems to be an
emerging standard in the D community.

 Longer term
-------------

Consider hiding Allegro completely. Or perhaps allow multiple
back-ends.

Think about a decent way to represent input devices uniquely. Also,
consider that joysticks can be plugged or unplugged at any time. This
should be supported.


 Some SDL 2 notes
------------------

If SDL 2 were complete by the time I started working on FewDee, it
would probably my choice for the "backend". As of now, I don't regret
to have chosen Allegro at all, but I know that SDL is a strong
alternative. So someday, I may chose to use SDL as the backend (or as
an alternative backend), and therefore it is interesting to see how
SDL 2 and Allegro 5 differ, and to what extent they are similar.

MULTIPLE WINDOWS: Both support multiple windows (or multiple screens,
in a multi-head setup). SDL calls each one a "screen"; Allegro,
"display".

HARDWARE AND SOFTWARE BITMAPS: Both have the concept of images stored
in either GPU (hardware) or CPU memory (software). In Allegro, there
is a single class: Bitmap; when it has a the ALLEGRO_MEMORY_BITMAP
flag enabled, it is in "CPU memory"; otherwise, it is in "GPU
memory". SDL 2 has two different classes: Surface (for "software
bitmaps") and Texture (for "hardware bitmaps").

CONVERSIONS BETWEEN HARDWARE AND SOFTWARE BITMAPS: Allegro seems to
allow the use of both bitmap types interchangeably (with different
performance levels). SDL 2 has a SDL_CreateTextureFromSurface()
function to convert from Surface to Texture; the opposite conversion
doesn't seem to exist.

BLIT: SDL_RenderCopy() blits part of a Texture to the current render
target, possibly with scaling; SDL_RenderCopyEx() additionally allows
to rotate and flip the Texture. SDL_BlitSurface() allow to blit a
Surface to another one (with scaling only). All SDL bliting respects
the current;y set blending mode, it seems. Allegro seems to allow both
types of bitmap to be written to each other freely (though there are
certainly performance trade-offs).

SUB-BITMAPS: Allegro allows to create explicit sub-bitmaps; SDL
doesn't have this concept, but all blitting functions take a "source
rectangle" parameter, that allow to draw just a part of the source
image.

COORDINATES: SDL 2 seems to use integer coordinates everywhere (via
SDL_Rect, sometimes). Allegro uses float coodinates. This is an
important difference!
