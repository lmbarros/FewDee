Check how exactly font sizes are specified in Allegro. Ensure that
AllegroFont works as documented.

Think about a sane way to do manage Allegro resources.

Go back to premultiplied alpha. Now that I understand it, it makes
much more sense. Maybe (this is longer term) I should have some way to
specify if the bitmap being loaded does already have the colors with
premultiplied alpha or not. Not doing the premultiplication uppon
loading (and having and editor that allows to edit the alpha channel
independently) would enable those neat effects like glowing neon signs
with a single image.

GUIsh what about z-order? Drawables have a "z" property; I can
implement a picking visitor that takes it into account. Then, GUIsh
should use this. Picking will pick Drawables only (and return a node
path!).

OSGUIsh can work with any node; GUIsh should allow that, too: any node
should be registerable; will need to walk up the picked node path
until finding a registered node (or not).

GUIsh: allow hierarchy of objects. (Will need to make AABBs much
better on the way.)

Sprite constructor taking arbitrary number of file names.

Sprite.contains() -> by transparency? Multiple containment policies?

Add means to remove objects/handlers from GUIsh.

Add means to remove objects/handlers from Updater. If necessary, make
the canned updaters compatible with this.

Add means to remove objects/handlers from Abstracted Input.

Create a "virtual screen" with a given "virtual size". Draw everything
relative to this virtual screen. Scale when drawing. But allow to use
"real pixels", too. (This would be an option when creating (or
re-creating, if possible) the display).

Add Text vertical alignment.

What if a state gets two events in the same "turn" and calls
pushState() in both of them? (Practical example: the player presses
"ESC" to get to the "in-game menu" state , and in the same "turn" he
is killed by a bullet, which triggers a transition to the "game over"
state.) Using Allegro events to manage the stack of states could be of
any help?

For Sprite: there is a handy al_get_parent_bitmap() function; this
would allow us to keep subbitmaps internally and return the "real"
bitmap for sorting purposes. Anyway, must implement a benchmark to
test how slower it is to render from different bitmaps versus from a
single one versus sub-bitmaps.

Group.addChild(): accept multiple children at a time? Technically,
would have to be renamed addChildren()... don't know if is necessary
in practice... must think about it.

Latest version of DAllegro includes a al_run_allegro() function that
should be used instead of simply putting all the code directly on
main() (for portability reasons). Check this out.

Make Sprites' AABB work for rotated sprite. Same for SRT.

Consider making Sprite and Text "base classes" (they would become more
like wrappers around Allegro objects), and create SpriteNode and
TextNode classes for the scene graph.

Consider using premultiplied alpha by default. Think on a nice way to
represent colors in the API.

Add more Command Triggers, including one to recognize sequences of
keys (both with time-constraints, like in fighting games, and without,
like in IDKFA).


 Optimization
--------------

Child nodes call a parents' method to tell to update their bounding
boxes because their own bounding box changed. This way, we'll always
have updated bounding boxes. [ initial implementation will always
recompute the AABB; this faster method will be implemented if deemed
necessary. ]

DrawingVisitor: Allow Drawables to share a common Transform. Then,
sort by transform to spare a couple of calls to
al_use_transform(). (Need to benchmark this; perhaps leave the sorting
policy as something user-definable)

DrawingVisitor: Add a 'bitmap' property to Drawables. Then, sort by
bitmap to avoid changing texture from draw to draw. BTW, remember to
take subbitmaps into account. (Need to benchmark this; perhaps leave
the sorting policy as something user-definable)

 Longer term
-------------

Consider hiding Allegro completely. Or perhaps allow multiple
back-ends.

Think about a decent way to represent input devices uniquely. Also,
consider that joysticks can be plugged or unplugged at any time. This
should be supported.


 Some SDL 2 notes
------------------

If SDL 2 were complete by the time I started working on FewDee, it
would probably my choice for the "backend". As of now, I don't regret
to have chosen Allegro at all, but I know that SDL is a strong
alternative. So someday, I may chose to use SDL as the backend (or as
an alternative backend), and therefore it is interesting to see how
SDL 2 and Allegro 5 differ, and to what extent they are similar.

MULTIPLE WINDOWS: Both support multiple windows (or multiple screens,
in a multi-head setup). SDL calls each one a "screen"; Allegro,
"display".

HARDWARE AND SOFTWARE BITMAPS: Both have the concept of images stored
in either GPU (hardware) or CPU memory (software). In Allegro, there
is a single class: Bitmap; when it has a the ALLEGRO_MEMORY_BITMAP
flag enabled, it is in "CPU memory"; otherwise, it is in "GPU
memory". SDL 2 has two different classes: Surface (for "software
bitmaps") and Texture (for "hardware bitmaps").

CONVERSIONS BETWEEN HARDWARE AND SOFTWARE BITMAPS: Allegro seems to
allow the use of both bitmap types interchangeably (with different
performance levels). SDL 2 has a SDL_CreateTextureFromSurface()
function to convert from Surface to Texture; the opposite conversion
doesn't seem to exist.

BLIT: SDL_RenderCopy() blits part of a Texture to the current render
target, possibly with scaling; SDL_RenderCopyEx() additionally allows
to rotate and flip the Texture. SDL_BlitSurface() allow to blit a
Surface to another one (with scaling only). All SDL bliting respects
the current;y set blending mode, it seems. Allegro seems to allow both
types of bitmap to be written to each other freely (though there are
certainly performance trade-offs).

SUB-BITMAPS: Allegro allows to create explicit sub-bitmaps; SDL
doesn't have this concept, but all blitting functions take a "source
rectangle" parameter, that allow to draw just a part of the source
image.

COORDINATES: SDL 2 seems to use integer coordinates everywhere (via
SDL_Rect, sometimes). Allegro uses float coodinates. This is an
important difference!
